pub trait TotalSizeIsMultipleOfEightBits {}
impl TotalSizeIsMultipleOfEightBits for ZeroMod8 {}

//transfer trait to keep the transfered name
pub trait RenamedType {
    type CheckType;
}

//type generator based on number
pub struct MultipleOfEight<const N: usize>;

//define all value-name maps
macro_rules! impl_size_type_pair {
    ($(($num:expr, $ident:ident)),*) => {
        $(
            pub struct $ident;
            impl RenamedType for MultipleOfEight<$num> {
                type CheckType = $ident;
            }
        )*
    };
}

impl_size_type_pair!(
    (0, ZeroMod8),
    (1, OneMod8),
    (2, TwoMod8),
    (3, ThreeMod8),
    (4, FourMod8),
    (5, FiveMod8),
    (6, SixMod8),
    (7, SevenMod8)
);

//connector trait, connect the type and bound
//the concrete type is generated by user
pub struct CheckMultipleOfEight<T>(std::marker::PhantomData<T>)
where
    T: RenamedType,
    <T as RenamedType>::CheckType: TotalSizeIsMultipleOfEightBits;

/*
 * Check For True/False
 * */

pub trait DiscriminantInRange {}
pub struct True;
pub struct False;
impl DiscriminantInRange for True {}

pub struct RangeWrapper<const F: bool>;
impl RenamedType for RangeWrapper<true> {
    type CheckType = True;
}
impl RenamedType for RangeWrapper<false> {
    type CheckType = False;
}

pub trait CheckRange<T>
where
    T: RenamedType,
    <T as RenamedType>::CheckType: DiscriminantInRange,
{
}

//bits Check
pub struct BitsCheck<T> {
    pub v: T,
}
